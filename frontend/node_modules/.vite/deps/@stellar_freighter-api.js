import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/@stellar/freighter-api/build/index.min.js
var require_index_min = __commonJS({
  "node_modules/@stellar/freighter-api/build/index.min.js"(exports, module) {
    !function(e, r) {
      "object" == typeof exports && "object" == typeof module ? module.exports = r() : "function" == typeof define && define.amd ? define([], r) : "object" == typeof exports ? exports.freighterApi = r() : e.freighterApi = r();
    }(exports, () => (() => {
      "use strict";
      var e, r, E = { d: (e2, r2) => {
        for (var o2 in r2) E.o(r2, o2) && !E.o(e2, o2) && Object.defineProperty(e2, o2, { enumerable: true, get: r2[o2] });
      }, o: (e2, r2) => Object.prototype.hasOwnProperty.call(e2, r2), r: (e2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      } }, o = {};
      E.r(o), E.d(o, { default: () => I, getNetwork: () => N, getNetworkDetails: () => s, getPublicKey: () => _, getUserInfo: () => R, isAllowed: () => C, isBrowser: () => c, isConnected: () => n, requestAccess: () => i, setAllowed: () => O, signAuthEntry: () => S, signBlob: () => A, signTransaction: () => t }), function(e2) {
        e2.CREATE_ACCOUNT = "CREATE_ACCOUNT", e2.FUND_ACCOUNT = "FUND_ACCOUNT", e2.ADD_ACCOUNT = "ADD_ACCOUNT", e2.IMPORT_ACCOUNT = "IMPORT_ACCOUNT", e2.IMPORT_HARDWARE_WALLET = "IMPORT_HARDWARE_WALLET", e2.LOAD_ACCOUNT = "LOAD_ACCOUNT", e2.MAKE_ACCOUNT_ACTIVE = "MAKE_ACCOUNT_ACTIVE", e2.UPDATE_ACCOUNT_NAME = "UPDATE_ACCOUNT_NAME", e2.GET_MNEMONIC_PHRASE = "GET_MNEMONIC_PHRASE", e2.CONFIRM_MNEMONIC_PHRASE = "CONFIRM_MNEMONIC_PHRASE", e2.CONFIRM_MIGRATED_MNEMONIC_PHRASE = "CONFIRM_MIGRATED_MNEMONIC_PHRASE", e2.RECOVER_ACCOUNT = "RECOVER_ACCOUNT", e2.CONFIRM_PASSWORD = "CONFIRM_PASSWORD", e2.REJECT_ACCESS = "REJECT_ACCESS", e2.GRANT_ACCESS = "GRANT_ACCESS", e2.SIGN_TRANSACTION = "SIGN_TRANSACTION", e2.SIGN_BLOB = "SIGN_BLOB", e2.SIGN_AUTH_ENTRY = "SIGN_AUTH_ENTRY", e2.HANDLE_SIGNED_HW_TRANSACTION = "HANDLE_SIGNED_HW_TRANSACTION", e2.REJECT_TRANSACTION = "REJECT_TRANSACTION", e2.SIGN_FREIGHTER_TRANSACTION = "SIGN_FREIGHTER_TRANSACTION", e2.SIGN_FREIGHTER_SOROBAN_TRANSACTION = "SIGN_FREIGHTER_SOROBAN_TRANSACTION", e2.ADD_RECENT_ADDRESS = "ADD_RECENT_ADDRESS", e2.LOAD_RECENT_ADDRESSES = "LOAD_RECENT_ADDRESSES", e2.SIGN_OUT = "SIGN_OUT", e2.SHOW_BACKUP_PHRASE = "SHOW_BACKUP_PHRASE", e2.SAVE_ALLOWLIST = "SAVE_ALLOWLIST", e2.SAVE_SETTINGS = "SAVE_SETTINGS", e2.LOAD_SETTINGS = "LOAD_SETTINGS", e2.GET_CACHED_ASSET_ICON = "GET_CACHED_ASSET_ICON", e2.CACHE_ASSET_ICON = "CACHE_ASSET_ICON", e2.GET_CACHED_ASSET_DOMAIN = "GET_CACHED_ASSET_DOMAIN", e2.CACHE_ASSET_DOMAIN = "CACHE_ASSET_DOMAIN", e2.GET_BLOCKED_ACCOUNTS = "GET_BLOCKED_ACCOUNTS", e2.GET_BLOCKED_DOMAINS = "GET_BLOCKED_DOMAINS", e2.ADD_CUSTOM_NETWORK = "ADD_CUSTOM_NETWORK", e2.CHANGE_NETWORK = "CHANGE_NETWORK", e2.REMOVE_CUSTOM_NETWORK = "REMOVE_CUSTOM_NETWORK", e2.EDIT_CUSTOM_NETWORK = "EDIT_CUSTOM_NETWORK", e2.RESET_EXP_DATA = "RESET_EXP_DATA", e2.ADD_TOKEN_ID = "ADD_TOKEN_ID", e2.GET_TOKEN_IDS = "GET_TOKEN_IDS", e2.REMOVE_TOKEN_ID = "REMOVE_TOKEN_ID", e2.GET_MIGRATABLE_ACCOUNTS = "GET_MIGRATABLE_ACCOUNTS", e2.GET_MIGRATED_MNEMONIC_PHRASE = "GET_MIGRATED_MNEMONIC_PHRASE", e2.MIGRATE_ACCOUNTS = "MIGRATE_ACCOUNTS";
      }(e || (e = {})), function(e2) {
        e2.REQUEST_ACCESS = "REQUEST_ACCESS", e2.REQUEST_PUBLIC_KEY = "REQUEST_PUBLIC_KEY", e2.SUBMIT_TRANSACTION = "SUBMIT_TRANSACTION", e2.SUBMIT_BLOB = "SUBMIT_BLOB", e2.SUBMIT_AUTH_ENTRY = "SUBMIT_AUTH_ENTRY", e2.REQUEST_NETWORK = "REQUEST_NETWORK", e2.REQUEST_NETWORK_DETAILS = "REQUEST_NETWORK_DETAILS", e2.REQUEST_CONNECTION_STATUS = "REQUEST_CONNECTION_STATUS", e2.REQUEST_ALLOWED_STATUS = "REQUEST_ALLOWED_STATUS", e2.SET_ALLOWED_STATUS = "SET_ALLOWED_STATUS", e2.REQUEST_USER_INFO = "REQUEST_USER_INFO";
      }(r || (r = {}));
      const T = (e2) => {
        const E2 = Date.now() + Math.random();
        return window.postMessage({ source: "FREIGHTER_EXTERNAL_MSG_REQUEST", messageId: E2, ...e2 }, window.location.origin), new Promise((o2) => {
          let T2 = 0;
          e2.type !== r.REQUEST_CONNECTION_STATUS && e2.type !== r.REQUEST_PUBLIC_KEY || (T2 = setTimeout(() => {
            o2({ isConnected: false, publicKey: "" }), window.removeEventListener("message", _2);
          }, 2e3));
          const _2 = (e3) => {
            var r2, t2;
            e3.source === window && "FREIGHTER_EXTERNAL_MSG_RESPONSE" === (null === (r2 = null == e3 ? void 0 : e3.data) || void 0 === r2 ? void 0 : r2.source) && (null === (t2 = null == e3 ? void 0 : e3.data) || void 0 === t2 ? void 0 : t2.messagedId) === E2 && (o2(e3.data), window.removeEventListener("message", _2), clearTimeout(T2));
          };
          window.addEventListener("message", _2, false);
        });
      }, _ = () => c ? (async () => {
        let e2 = { publicKey: "", error: "" };
        try {
          e2 = await T({ type: r.REQUEST_PUBLIC_KEY });
        } catch (e3) {
          console.error(e3);
        }
        const { publicKey: E2, error: o2 } = e2;
        if (o2) throw o2;
        return E2;
      })() : Promise.resolve(""), t = (e2, E2) => c ? (async (e3, E3, o2) => {
        let _2 = "", t2 = "", A2 = "";
        "object" == typeof E3 ? (_2 = E3.network || "", t2 = E3.accountToSign || "", A2 = E3.networkPassphrase || "") : (_2 = E3 || "", t2 = "");
        let S2 = { signedTransaction: "", error: "" };
        try {
          S2 = await T({ transactionXdr: e3, network: _2, networkPassphrase: A2, accountToSign: t2, type: r.SUBMIT_TRANSACTION });
        } catch (e4) {
          throw console.error(e4), e4;
        }
        const { signedTransaction: n2, error: N2 } = S2;
        if (N2) throw N2;
        return n2;
      })(e2, E2) : Promise.resolve(""), A = (e2, E2) => c ? (async (e3, E3) => {
        let o2 = { signedBlob: "", error: "" };
        const _2 = (E3 || {}).accountToSign || "";
        try {
          o2 = await T({ blob: e3, accountToSign: _2, type: r.SUBMIT_BLOB });
        } catch (e4) {
          throw console.error(e4), e4;
        }
        const { signedBlob: t2, error: A2 } = o2;
        if (A2) throw A2;
        return t2;
      })(e2, E2) : Promise.resolve(""), S = (e2, E2) => c ? (async (e3, E3) => {
        let o2 = { signedAuthEntry: "", error: "" };
        const _2 = (E3 || {}).accountToSign || "";
        try {
          o2 = await T({ entryXdr: e3, accountToSign: _2, type: r.SUBMIT_AUTH_ENTRY });
        } catch (e4) {
          console.error(e4);
        }
        const { signedAuthEntry: t2, error: A2 } = o2;
        if (A2) throw A2;
        return t2;
      })(e2, E2) : Promise.resolve(""), n = () => c ? window.freighter ? Promise.resolve(window.freighter) : (async () => {
        let e2 = { isConnected: false };
        try {
          e2 = await T({ type: r.REQUEST_CONNECTION_STATUS });
        } catch (e3) {
          console.error(e3);
        }
        return e2.isConnected;
      })() : Promise.resolve(false), N = () => c ? (async () => {
        let e2 = { network: "", error: "" };
        try {
          e2 = await T({ type: r.REQUEST_NETWORK });
        } catch (e3) {
          console.error(e3);
        }
        const { network: E2, error: o2 } = e2;
        if (o2) throw o2;
        return E2;
      })() : Promise.resolve(""), s = () => c ? (async () => {
        let e2 = { networkDetails: { network: "", networkName: "", networkUrl: "", networkPassphrase: "", sorobanRpcUrl: void 0 }, error: "" };
        try {
          e2 = await T({ type: r.REQUEST_NETWORK_DETAILS });
        } catch (e3) {
          console.error(e3);
        }
        const { networkDetails: E2, error: o2 } = e2, { network: _2, networkUrl: t2, networkPassphrase: A2, sorobanRpcUrl: S2 } = E2;
        if (o2) throw o2;
        return { network: _2, networkUrl: t2, networkPassphrase: A2, sorobanRpcUrl: S2 };
      })() : Promise.resolve({ network: "", networkUrl: "", networkPassphrase: "", sorobanRpcUrl: "" }), C = () => c ? (async () => {
        let e2 = { isAllowed: false };
        try {
          e2 = await T({ type: r.REQUEST_ALLOWED_STATUS });
        } catch (e3) {
          console.error(e3);
        }
        return e2.isAllowed;
      })() : Promise.resolve(false), O = () => c ? (async () => {
        let e2 = { isAllowed: false, error: "" };
        try {
          e2 = await T({ type: r.SET_ALLOWED_STATUS });
        } catch (e3) {
          console.error(e3);
        }
        const { isAllowed: E2, error: o2 } = e2;
        if (o2) throw o2;
        return E2;
      })() : Promise.resolve(false), R = () => c ? (async () => {
        let e2 = { userInfo: { publicKey: "" }, error: "" };
        try {
          e2 = await T({ type: r.REQUEST_USER_INFO });
        } catch (e3) {
          console.error(e3);
        }
        const { userInfo: E2, error: o2 } = e2;
        if (o2) throw o2;
        return E2;
      })() : Promise.resolve({ publicKey: "" }), i = () => c ? (async () => {
        let e2 = { publicKey: "", error: "" };
        try {
          e2 = await T({ type: r.REQUEST_ACCESS });
        } catch (e3) {
          console.error(e3);
        }
        const { publicKey: E2, error: o2 } = e2;
        if (o2) throw o2;
        return E2;
      })() : Promise.resolve(""), c = "undefined" != typeof window, I = { getPublicKey: _, signTransaction: t, signBlob: A, signAuthEntry: S, isConnected: n, getNetwork: N, getNetworkDetails: s, isAllowed: C, setAllowed: O, getUserInfo: R, requestAccess: i };
      return o;
    })());
  }
});
export default require_index_min();
//# sourceMappingURL=@stellar_freighter-api.js.map
